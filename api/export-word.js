// Vercel API Route - Document Export
export default async function handler(req, res) {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
        res.status(200).end();
        return;
    }
    
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }
    
    try {
        const { text, options = {} } = req.body;
        
        if (!text || typeof text !== 'string') {
            return res.status(400).json({ error: 'Text is required and must be a string' });
        }
        
        // Import docx library
        const docx = require('docx');
        const { Document, Paragraph, TextRun, Packer } = docx;
        
        // Parse options
        const {
            title = 'Document',
            author = 'Enhanced Novel Crafter',
            fontSize = 12,
            fontFamily = 'Times New Roman'
        } = options;
        
        // Parse paragraphs properly to preserve formatting
        const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
        
        // Create document elements
        const docElements = [];
        
        // Add title if provided
        if (title && title !== 'Document') {
            docElements.push(
                new Paragraph({
                    children: [
                        new TextRun({
                            text: title,
                            bold: true,
                            size: (fontSize + 4) * 2, // Convert to half-points
                            font: fontFamily
                        })
                    ],
                    spacing: { after: 400 }
                })
            );
        }
        
        // Process each paragraph
        paragraphs.forEach(paragraphText => {
            const lines = paragraphText.split('\n').filter(line => line.trim().length > 0);
            
            lines.forEach(line => {
                docElements.push(
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: line.trim(),
                                size: fontSize * 2, // Convert to half-points
                                font: fontFamily
                            })
                        ],
                        spacing: { after: 200 }
                    })
                );
            });
            
            // Add spacing between paragraphs
            if (paragraphs.indexOf(paragraphText) < paragraphs.length - 1) {
                docElements.push(
                    new Paragraph({
                        children: [new TextRun({ text: '' })],
                        spacing: { after: 200 }
                    })
                );
            }
        });
        
        // Create the document
        const doc = new Document({
            sections: [{
                properties: {
                    page: {
                        margin: {
                            top: 1440,    // 1 inch (in twips)
                            right: 1440,  // 1 inch
                            bottom: 1440, // 1 inch
                            left: 1440    // 1 inch
                        }
                    }
                },
                children: docElements
            }],
            creator: author,
            title: title,
            description: 'Generated by Enhanced Novel Crafter'
        });
        
        // Generate the document buffer
        const buffer = await Packer.toBuffer(doc);
        
        // Set headers for file download
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
        res.setHeader('Content-Disposition', `attachment; filename="${title.replace(/[^a-zA-Z0-9]/g, '_')}.docx"`);
        res.setHeader('Content-Length', buffer.length);
        
        // Send the buffer
        res.status(200).send(buffer);
        
    } catch (error) {
        console.error('Export Error:', error);
        res.status(500).json({ error: 'Export failed', message: error.message });
    }
}
